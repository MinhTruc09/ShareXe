import 'dart:convert';
import 'dart:async';
import 'package:stomp_dart_client/stomp_dart_client.dart';
import '../models/notification_model.dart';
import '../models/chat_message_model.dart';
import 'package:flutter/foundation.dart';
import '../utils/app_config.dart';
import 'dart:math';

class WebSocketService {
  static final WebSocketService _instance = WebSocketService._internal();
  factory WebSocketService() => _instance;
  WebSocketService._internal();

  StompClient? _stompClient;
  Function(NotificationModel)? onNotificationReceived;
  Function(ChatMessageModel)? onChatMessageReceived;
  String? _userEmail;
  String? _token;
  final AppConfig _appConfig = AppConfig();
  Timer? _heartbeatTimer;
  Timer? _reconnectTimer;
  bool _isReconnecting = false;
  int _reconnectAttempts = 0;
  static const int MAX_RECONNECT_ATTEMPTS = 10;
  double _reconnectDelay = 1.0;
  static const double MAX_RECONNECT_DELAY = 60.0;
  bool _manualDisconnect = false;
  Function(String, bool)? onUserStatusChanged;

  void initialize(String serverUrl, String token, String userEmail) {
    // N·∫øu kh√¥ng c√≥ thay ƒë·ªïi th√¥ng tin v√† ƒë√£ k·∫øt n·ªëi, kh√¥ng t·∫°o k·∫øt n·ªëi m·ªõi
    if (_userEmail == userEmail &&
        _token == token &&
        _stompClient?.connected == true) {
      if (kDebugMode) {
        print(
          '‚ö†Ô∏è ƒê√£ c√≥ k·∫øt n·ªëi WebSocket ho·∫°t ƒë·ªông v·ªõi c√πng th√¥ng tin, b·ªè qua vi·ªác kh·ªüi t·∫°o l·∫°i',
        );
      }
      return;
    }

    _userEmail = userEmail;
    _token = token;

    if (serverUrl.isNotEmpty) {
      _appConfig.updateBaseUrl(serverUrl);
    }

    // Cleanup existing connections and timers
    _cleanupExistingConnection();

    final socketUrl = _appConfig.webSocketUrl;
    if (kDebugMode) {
      print('üîÑ Kh·ªüi t·∫°o WebSocket v·ªõi URL: $socketUrl');
      print(
        'üîë Token: ${token.length > 20 ? "${token.substring(0, 20)}..." : token}',
      );
      print('üë§ Ng∆∞·ªùi d√πng: $_userEmail');
    }

    try {
      _stompClient = StompClient(
        config: StompConfig(
          url: socketUrl,
          onConnect: _onConnect,
          onStompError: (frame) {
            if (kDebugMode) {
              print('‚ùå L·ªói STOMP: ${frame.headers}');
              print('‚ùå N·ªôi dung l·ªói: ${frame.body}');
            }
            _scheduleReconnect();
          },
          onDisconnect: (_) {
            if (kDebugMode) {
              print('‚ùå WebSocket ƒë√£ ng·∫Øt k·∫øt n·ªëi');
            }
            _scheduleReconnect();
          },
          onWebSocketError: (error) {
            if (kDebugMode) {
              print('‚ùå L·ªói WebSocket: $error');
            }
            _scheduleReconnect();
          },
          onWebSocketDone: () {
            if (kDebugMode) {
              print('‚ùå WebSocket k·∫øt n·ªëi ƒë√£ ƒë√≥ng');
            }
            _scheduleReconnect();
          },
          stompConnectHeaders: {'Authorization': 'Bearer $token'},
          webSocketConnectHeaders: {'Authorization': 'Bearer $token'},
          connectionTimeout: const Duration(seconds: 10),
          heartbeatOutgoing: const Duration(seconds: 5),
          heartbeatIncoming: const Duration(seconds: 5),
          reconnectDelay: const Duration(milliseconds: 1000),
        ),
      );

      if (kDebugMode) {
        print('üîÑ ƒêang k√≠ch ho·∫°t k·∫øt n·ªëi WebSocket...');
      }
      _stompClient!.activate();
      _startHeartbeat();

      // ƒê·∫∑t th·ªùi gian ch·ªù cho k·∫øt n·ªëi ban ƒë·∫ßu
      Future.delayed(const Duration(seconds: 5), () {
        if (_stompClient != null && !_stompClient!.connected) {
          if (kDebugMode) {
            print('‚ùå WebSocket kh√¥ng th·ªÉ k·∫øt n·ªëi sau 5 gi√¢y, th·ª≠ l·∫°i...');
          }
          _scheduleReconnect(immediate: true);
        }
      });
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå L·ªói kh·ªüi t·∫°o WebSocket: $e');
      }
      _scheduleReconnect();
    }
  }

  // D·ªçn d·∫πp k·∫øt n·ªëi v√† b·ªô ƒë·∫øm th·ªùi gian hi·ªán t·∫°i
  void _cleanupExistingConnection() {
    _heartbeatTimer?.cancel();
    _reconnectTimer?.cancel();
    _reconnectAttempts = 0;
    _isReconnecting = false;

    if (_stompClient != null) {
      if (_stompClient!.connected) {
        if (kDebugMode) {
          print('üîÑ WebSocket ƒë√£ k·∫øt n·ªëi, ng·∫Øt k·∫øt n·ªëi tr∆∞·ªõc khi kh·ªüi t·∫°o l·∫°i');
        }
        disconnect();
      } else {
        if (kDebugMode) {
          print(
            'üîÑ WebSocket ƒëang c√≥ k·∫øt n·ªëi kh√¥ng ho·∫°t ƒë·ªông, h·ªßy v√† kh·ªüi t·∫°o l·∫°i',
          );
        }
        _stompClient!.deactivate();
        _stompClient = null;
      }
    }
  }

  // B·∫Øt ƒë·∫ßu g·ª≠i heartbeat ƒë·ªãnh k·ª≥ ƒë·ªÉ ki·ªÉm tra k·∫øt n·ªëi
  void _startHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = Timer.periodic(const Duration(seconds: 10), (timer) {
      if (_stompClient != null) {
        if (!_stompClient!.connected) {
          if (kDebugMode) {
            print('üíì Ph√°t hi·ªán m·∫•t k·∫øt n·ªëi qua heartbeat, th·ª≠ k·∫øt n·ªëi l·∫°i...');
          }
          _scheduleReconnect(immediate: true);
        } else {
          if (kDebugMode) {
            print('üíì Heartbeat: WebSocket v·∫´n ƒëang k·∫øt n·ªëi.');
          }

          // G·ª≠i m·ªôt ping ƒë·ªÉ gi·ªØ k·∫øt n·ªëi s·ªëng
          try {
            _stompClient!.send(
              destination: '/app/ping',
              body: json.encode({
                'timestamp': DateTime.now().toIso8601String(),
              }),
            );
          } catch (e) {
            if (kDebugMode) {
              print('‚ùå L·ªói g·ª≠i ping: $e - S·∫Ω th·ª≠ k·∫øt n·ªëi l·∫°i');
            }
            _scheduleReconnect();
          }
        }
      } else {
        if (kDebugMode) {
          print(
            'üíì Heartbeat: StompClient ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o, th·ª≠ k·∫øt n·ªëi l·∫°i',
          );
        }
        _scheduleReconnect(immediate: true);
      }
    });
  }

  // B·∫Øt ƒë·∫ßu k·∫øt n·ªëi l·∫°i
  void _scheduleReconnect({bool immediate = false}) {
    // N·∫øu vi·ªác ng·∫Øt k·∫øt n·ªëi l√† do ng∆∞·ªùi d√πng ch·ªß √Ω th·ª±c hi·ªán, kh√¥ng t·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i
    if (_manualDisconnect) {
      if (kDebugMode) {
        print(
          '‚ö†Ô∏è Kh√¥ng t·ª± ƒë·ªông k·∫øt n·ªëi l·∫°i v√¨ ng∆∞·ªùi d√πng ƒë√£ ch·ªß ƒë·ªông ng·∫Øt k·∫øt n·ªëi',
        );
      }
      return;
    }

    // N·∫øu ƒëang trong qu√° tr√¨nh k·∫øt n·ªëi l·∫°i ho·∫∑c ƒë√£ v∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠ l·∫°i, kh√¥ng th·ª±c hi·ªán th√™m
    if (_isReconnecting || _reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      if (_reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
        if (kDebugMode) {
          print(
            '‚ùå ƒê√£ ƒë·∫°t gi·ªõi h·∫°n k·∫øt n·ªëi l·∫°i (${MAX_RECONNECT_ATTEMPTS} l·∫ßn). D·ª´ng th·ª≠ l·∫°i.',
          );
        }
      }
      return;
    }

    _isReconnecting = true;
    _reconnectAttempts++;

    if (kDebugMode) {
      print(
        'üîÑ L√™n l·ªãch k·∫øt n·ªëi l·∫°i sau $_reconnectDelay gi√¢y (l·∫ßn th·ª≠: $_reconnectAttempts)',
      );
    }

    // Gi·ªõi h·∫°n t·ªïng s·ªë l·∫ßn k·∫øt n·ªëi l·∫°i
    if (_reconnectAttempts <= MAX_RECONNECT_ATTEMPTS) {
      _reconnectTimer?.cancel();
      _reconnectTimer = Timer(
        Duration(seconds: immediate ? 0 : _reconnectDelay.toInt()),
        () {
          _performReconnect();

          // TƒÉng th·ªùi gian ch·ªù cho l·∫ßn k·∫øt n·ªëi ti·∫øp theo (max 60 gi√¢y)
          _reconnectDelay =
              (_reconnectDelay * 1.5 < MAX_RECONNECT_DELAY)
                  ? _reconnectDelay * 1.5
                  : MAX_RECONNECT_DELAY;
        },
      );
    } else {
      if (kDebugMode) {
        print('‚ö†Ô∏è ƒê√£ v∆∞·ª£t qu√° s·ªë l·∫ßn th·ª≠ k·∫øt n·ªëi l·∫°i t·ªëi ƒëa. H√£y th·ª≠ l·∫°i sau.');
      }
      // Reset ƒë·ªÉ cho ph√©p th·ª≠ l·∫°i n·∫øu ng∆∞·ªùi d√πng t∆∞∆°ng t√°c
      _reconnectAttempts = 0;
      _isReconnecting = false;
    }
  }

  // Th·ª±c hi·ªán k·∫øt n·ªëi l·∫°i
  void _performReconnect() {
    if (_token == null || _userEmail == null) {
      if (kDebugMode) {
        print('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi l·∫°i: thi·∫øu token ho·∫∑c email ng∆∞·ªùi d√πng');
      }
      _isReconnecting = false;
      return;
    }

    try {
      if (kDebugMode) {
        print('üîÑ ƒêang th·ª±c hi·ªán k·∫øt n·ªëi l·∫°i WebSocket...');
      }

      // ƒê·∫£m b·∫£o ƒë√£ d·ªçn d·∫πp k·∫øt n·ªëi c≈©
      if (_stompClient != null) {
        _stompClient!.deactivate();
        _stompClient = null;
      }

      // Tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n, ƒë·∫∑t c·ªù ƒë·ªÉ ngƒÉn vi·ªác k·∫øt n·ªëi l·∫°i t·ª± ƒë·ªông trong qu√° tr√¨nh ƒëang c·ªë g·∫Øng k·∫øt n·ªëi l·∫°i
      _isReconnecting = true;

      // Kh·ªüi t·∫°o l·∫°i k·∫øt n·ªëi m·ªõi
      final socketUrl = _appConfig.webSocketUrl;

      if (kDebugMode) {
        print('üîÑ Kh·ªüi t·∫°o l·∫°i WebSocket v·ªõi URL: $socketUrl');
      }

      _stompClient = StompClient(
        config: StompConfig(
          url: socketUrl,
          onConnect: (frame) {
            _onConnect(frame);
            // Reset khi k·∫øt n·ªëi th√†nh c√¥ng
            _reconnectAttempts = 0;
            _reconnectDelay = 1.0;
            _isReconnecting = false;
          },
          onStompError: (frame) {
            if (kDebugMode) {
              print('‚ùå L·ªói STOMP khi reconnect: ${frame.headers}');
            }
            _isReconnecting = false;
          },
          onDisconnect: (_) {
            if (kDebugMode) {
              print('‚ùå WebSocket ƒë√£ ng·∫Øt k·∫øt n·ªëi trong qu√° tr√¨nh reconnect');
            }
            _isReconnecting = false;
          },
          onWebSocketError: (error) {
            if (kDebugMode) {
              print('‚ùå L·ªói WebSocket trong qu√° tr√¨nh reconnect: $error');
            }
            _isReconnecting = false;
          },
          onWebSocketDone: () {
            if (kDebugMode) {
              print('‚ùå WebSocket k·∫øt n·ªëi ƒë√£ ƒë√≥ng trong qu√° tr√¨nh reconnect');
            }
            _isReconnecting = false;
          },
          stompConnectHeaders: {'Authorization': 'Bearer $_token'},
          webSocketConnectHeaders: {'Authorization': 'Bearer $_token'},
          connectionTimeout: const Duration(seconds: 10),
          heartbeatOutgoing: const Duration(seconds: 5),
          heartbeatIncoming: const Duration(seconds: 5),
          reconnectDelay: const Duration(milliseconds: 1000),
        ),
      );

      _stompClient!.activate();

      // ƒê·∫∑t timeout cho vi·ªác k·∫øt n·ªëi l·∫°i
      Future.delayed(const Duration(seconds: 10), () {
        if (_stompClient != null &&
            !_stompClient!.connected &&
            _isReconnecting) {
          if (kDebugMode) {
            print('‚åõ Timeout k·∫øt n·ªëi l·∫°i sau 10 gi√¢y');
          }
          _isReconnecting = false;
        }
      });
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå L·ªói khi th·ª±c hi·ªán k·∫øt n·ªëi l·∫°i: $e');
      }
      _isReconnecting = false;
    }
  }

  // X·ª≠ l√Ω khi k·∫øt n·ªëi WebSocket th√†nh c√¥ng
  void _onConnect(StompFrame frame) {
    if (kDebugMode) {
      print('\n');
      print('‚úÖ WebSocket ƒë√£ k·∫øt n·ªëi th√†nh c√¥ng!');
      print('üîë Thi·∫øt l·∫≠p subscriptions...');
    }

    // Reset reconnect state
    _reconnectAttempts = 0;
    _reconnectDelay = 1.0;
    _isReconnecting = false;
    _manualDisconnect = false;

    _setupSubscriptions();
  }

  // Thi·∫øt l·∫≠p c√°c k√™nh ƒëƒÉng k√Ω nh·∫≠n th√¥ng b√°o
  void _setupSubscriptions() {
    // H·ªßy k√™nh c≈© n·∫øu c√≥
    _unsubscribeAll();

    if (_userEmail == null) {
      if (kDebugMode) {
        print('‚ùå Kh√¥ng th·ªÉ ƒëƒÉng k√Ω subscriptions v√¨ kh√¥ng c√≥ email ng∆∞·ªùi d√πng');
      }
      return;
    }

    try {
      // 1. L·∫Øng nghe k√™nh cho ng∆∞·ªùi d√πng c·ª• th·ªÉ (d√πng ƒë·ªÉ nh·∫≠n tin nh·∫Øn chat)
      if (kDebugMode) {
        print('üîî ƒêƒÉng k√Ω nh·∫≠n tin nh·∫Øn cho ng∆∞·ªùi d√πng: $_userEmail');
      }

      _stompClient!.subscribe(
        destination: '/topic/chat/$_userEmail',
        callback: (frame) {
          if (kDebugMode) {
            print('\nüì® Nh·∫≠n tin nh·∫Øn cho ng∆∞·ªùi d√πng $_userEmail:');
            print('üìÑ N·ªôi dung: ${frame.body}');
          }
          _handleChatMessageReceived(frame);
        },
      );

      // 2. L·∫Øng nghe k√™nh th√¥ng b√°o chung
      if (kDebugMode) {
        print('üîî ƒêƒÉng k√Ω nh·∫≠n th√¥ng b√°o chung cho ng∆∞·ªùi d√πng');
      }

      _stompClient!.subscribe(
        destination: '/topic/notifications',
        callback: (frame) {
          if (kDebugMode) {
            print('\nüîî Nh·∫≠n th√¥ng b√°o chung:');
            print('üìÑ N·ªôi dung: ${frame.body}');
          }
          _handleNotificationReceived(frame);
        },
      );

      // Th√™m x·ª≠ l√Ω cho topic /topic/receipt/{email} v√† /topic/receipt/{roomId}
      _stompClient?.subscribe(
        destination: '/topic/receipt/$_userEmail',
        callback: (frame) {
          try {
            final data = json.decode(frame.body!);
            if (kDebugMode) {
              print('üì© Nh·∫≠n delivery receipt: $data');
            }

            // X·ª≠ l√Ω tr·∫°ng th√°i tin nh·∫Øn
            if (data['status'] == 'DELIVERED') {
              // C·∫≠p nh·∫≠t tr·∫°ng th√°i tin nh·∫Øn ƒë√£ g·ª≠i
              // ...
            } else if (data['status'] == 'READ') {
              // C·∫≠p nh·∫≠t tr·∫°ng th√°i tin nh·∫Øn ƒë√£ ƒë·ªçc
              // ...
            }
          } catch (e) {
            if (kDebugMode) {
              print('‚ùå L·ªói khi x·ª≠ l√Ω receipt: $e');
            }
          }
        },
      );

      if (kDebugMode) {
        print('üîî ƒê√£ ƒëƒÉng k√Ω th√†nh c√¥ng c√°c k√™nh th√¥ng b√°o!');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå L·ªói khi ƒëƒÉng k√Ω subscriptions: $e');
      }
    }
  }

  // H·ªßy t·∫•t c·∫£ c√°c ƒëƒÉng k√Ω hi·ªán t·∫°i
  void _unsubscribeAll() {
    if (_stompClient != null && _stompClient!.connected) {
      try {
        // Kh√¥ng c√≥ API tr·ª±c ti·∫øp ƒë·ªÉ unsubscribe t·∫•t c·∫£
        // Stomp client t·ª± qu·∫£n l√Ω vi·ªác n√†y
        if (kDebugMode) {
          print('üîî ƒê√£ h·ªßy ƒëƒÉng k√Ω c√°c k√™nh c≈©');
        }
      } catch (e) {
        if (kDebugMode) {
          print('‚ùå L·ªói khi h·ªßy ƒëƒÉng k√Ω: $e');
        }
      }
    }
  }

  bool isConnected() {
    if (_stompClient == null) {
      if (kDebugMode) {
        print('‚ùå StompClient ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o');
      }
      return false;
    }

    final connected = _stompClient!.connected;
    if (kDebugMode) {
      print(
        'üîç Tr·∫°ng th√°i k·∫øt n·ªëi WebSocket: ${connected ? "‚úÖ ƒê√£ k·∫øt n·ªëi" : "‚ùå Ch∆∞a k·∫øt n·ªëi"}',
      );
    }
    return connected;
  }

  // G·ª≠i tin nh·∫Øn chat
  Future<bool> sendChatMessage(
    String roomId,
    String receiverEmail,
    String content,
  ) async {
    if (kDebugMode) {
      print('üì§ Th·ª≠ g·ª≠i tin nh·∫Øn chat qua WebSocket');
      print('üì§ Room ID: $roomId');
      print('üì§ Receiver Email: $receiverEmail');
      print('üì§ Content: $content');
    }

    return _trySendChatMessage(roomId, receiverEmail, content);
  }

  // Th·ª≠ g·ª≠i tin nh·∫Øn qua WebSocket v·ªõi c∆° ch·∫ø ki·ªÉm tra tr·∫°ng th√°i k·∫øt n·ªëi
  Future<bool> _trySendChatMessage(
    String roomId,
    String receiverEmail,
    String content,
  ) async {
    // N·∫øu ƒëang c√≥ qu√° nhi·ªÅu th·ª≠ l·∫°i ho·∫∑c WebSocket kh√¥ng ƒë∆∞·ª£c k·∫øt n·ªëi ƒë√∫ng c√°ch, tr·∫£ v·ªÅ false ngay l·∫≠p t·ª©c
    if (_stompClient == null || !_stompClient!.connected) {
      if (kDebugMode) {
        print('‚ùå Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn: WebSocket ch∆∞a ƒë∆∞·ª£c k·∫øt n·ªëi');
        print('üîç Tr·∫°ng th√°i k·∫øt n·ªëi: ${_stompClient?.connected}');
      }
      return false;
    }

    try {
      // ƒê·∫£m b·∫£o ƒë√£ c√≥ th√¥ng tin ng∆∞·ªùi d√πng
      if (_userEmail == null) {
        if (kDebugMode) {
          print('‚ùå L·ªói: Ch∆∞a c√≥ th√¥ng tin ng∆∞·ªùi d√πng ƒë·ªÉ g·ª≠i tin nh·∫Øn');
        }
        return false;
      }

      // T·∫°o payload cho tin nh·∫Øn
      final message = {
        'roomId': roomId,
        'senderEmail': _userEmail,
        'receiverEmail': receiverEmail,
        'content': content,
        'timestamp': DateTime.now().toIso8601String(),
        'token': _token?.replaceAll('Bearer ', ''),
      };

      // QUAN TR·ªåNG: ƒê·∫£m b·∫£o g·ª≠i ƒë·∫øn ƒë√∫ng destination c·ªßa server
      // ƒê∆∞·ªùng d·∫´n ch√≠nh x√°c l√† /app/chat/{roomId} - ƒë√¢y l√† n∆°i server ƒëang l·∫Øng nghe
      final destination = '/app/chat/$roomId';

      // G·ª≠i tin nh·∫Øn
      if (kDebugMode) {
        print('----------------------------------------------');
        print('üì§ SENDING WEBSOCKET MESSAGE:');
        print('üì§ Destination: $destination');
        print('üì§ Room ID: $roomId');
        print('üì§ Sender: $_userEmail');
        print('üì§ Receiver: $receiverEmail');
        print('üì§ Content: $content');
        if (_token != null) {
          final int maxLength = 20;
          final int tokenLength = _token!.length;
          final int subLength =
              tokenLength < maxLength ? tokenLength : maxLength;
          print('üì§ Token: ${_token!.substring(0, subLength)}...');
        } else {
          print('üì§ Token: NULL (No authentication token)');
        }
        print('üì§ Full Message: ${json.encode(message)}');
        print('----------------------------------------------');
      }

      // Th·ª±c hi·ªán g·ª≠i tin nh·∫Øn
      try {
        _stompClient!.send(
          destination: destination,
          body: json.encode(message),
          headers: {'content-type': 'application/json'},
        );

        if (kDebugMode) {
          print('‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn qua WebSocket, ƒëang ch·ªù ph·∫£n h·ªìi...');
        }

        // G·ª≠i l·∫°i m·ªôt l·∫ßn n·ªØa sau 300ms ƒë·ªÉ ƒë·∫£m b·∫£o tin nh·∫Øn ƒë∆∞·ª£c g·ª≠i ƒëi (ph√≤ng tr∆∞·ªùng h·ª£p l·ªói truy·ªÅn tin)
        Future.delayed(const Duration(milliseconds: 300), () {
          try {
            _stompClient!.send(
              destination: destination,
              body: json.encode(message),
              headers: {'content-type': 'application/json'},
            );
            if (kDebugMode) {
              print(
                '‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn l·∫ßn th·ª© 2 ƒë·ªÉ ƒë·∫£m b·∫£o tin nh·∫Øn ƒë∆∞·ª£c nh·∫≠n',
              );
            }
          } catch (e) {
            if (kDebugMode) {
              print('‚ùå L·ªói khi g·ª≠i tin nh·∫Øn l·∫ßn th·ª© 2: $e');
            }
          }
        });

        // Kh√¥ng c√≥ c√°ch n√†o ƒë·ªÉ bi·∫øt tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω th√†nh c√¥ng hay ch∆∞a trong STOMP,
        // n√™n ta m·∫∑c ƒë·ªãnh tr·∫£ v·ªÅ true v√† x·ª≠ l√Ω th√†nh c√¥ng
        return true;
      } catch (sendError) {
        if (kDebugMode) {
          print('‚ùå L·ªói khi g·ª≠i tin nh·∫Øn qua STOMP client: $sendError');
        }
        throw sendError; // N√©m l·ªói ƒë·ªÉ x·ª≠ l√Ω ·ªü ngo√†i
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå L·ªói khi g·ª≠i tin nh·∫Øn qua WebSocket: $e');
      }
      return false;
    }
  }

  // Helper function to get min value
  int min(int a, int b) => a < b ? a : b;

  void disconnect() {
    _manualDisconnect = true;

    if (kDebugMode) {
      print('üîå Ng·∫Øt k·∫øt n·ªëi WebSocket theo y√™u c·∫ßu');
    }

    _heartbeatTimer?.cancel();
    _reconnectTimer?.cancel();

    if (_stompClient != null && _stompClient!.connected) {
      _stompClient!.deactivate();
    }

    _stompClient = null;

    // Sau 5 gi√¢y, cho ph√©p k·∫øt n·ªëi l·∫°i n·∫øu c·∫ßn
    Future.delayed(const Duration(seconds: 5), () {
      _manualDisconnect = false;
    });
  }

  // ƒêƒÉng k√Ω l·∫Øng nghe tr·∫°ng th√°i ƒëang g√µ
  void subscribeToTypingStatus(String roomId) {
    _stompClient?.subscribe(
      destination: '/topic/typing/$roomId',
      callback: (frame) {
        try {
          final data = json.decode(frame.body!);
          // Th√¥ng b√°o c√≥ ng∆∞·ªùi ƒëang g√µ
          // ...
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå L·ªói khi x·ª≠ l√Ω tr·∫°ng th√°i ƒëang g√µ: $e');
          }
        }
      },
    );
  }

  // G·ª≠i tr·∫°ng th√°i ƒëang g√µ
  void sendTypingStatus(String roomId, bool isTyping) {
    if (_stompClient?.connected ?? false) {
      final payload = {'isTyping': isTyping};

      _stompClient?.send(
        destination: '/app/chat.typing/$roomId',
        body: json.encode(payload),
      );
    }
  }

  // G·ª≠i x√°c nh·∫≠n ƒë√£ ƒë·ªçc tin nh·∫Øn
  void markMessagesAsRead(String roomId) {
    if (_stompClient?.connected ?? false) {
      _stompClient?.send(
        destination: '/app/chat.markRead/$roomId',
        body: json.encode({}),
      );
    }
  }

  // Th√™m ph∆∞∆°ng th·ª©c subscribe v√†o ChatService ho·∫∑c WebSocketService
  void subscribeToUserStatus() {
    _stompClient?.subscribe(
      destination: '/topic/user-status',
      callback: (frame) {
        try {
          final data = json.decode(frame.body!);
          final userEmail = data['userEmail'];
          final isOnline = data['online'];

          if (onUserStatusChanged != null) {
            onUserStatusChanged!(userEmail, isOnline);
          }

          if (kDebugMode) {
            print(
              'üë§ Tr·∫°ng th√°i ng∆∞·ªùi d√πng: $userEmail - ${isOnline ? "online" : "offline"}',
            );
          }
        } catch (e) {
          if (kDebugMode) {
            print('‚ùå L·ªói khi x·ª≠ l√Ω tr·∫°ng th√°i ng∆∞·ªùi d√πng: $e');
          }
        }
      },
    );
  }

  // Ph∆∞∆°ng th·ª©c x·ª≠ l√Ω tin nh·∫Øn chat nh·∫≠n ƒë∆∞·ª£c
  void _handleChatMessageReceived(StompFrame frame) {
    try {
      if (frame.body == null) {
        if (kDebugMode) {
          print('‚ùå Nh·∫≠n ƒë∆∞·ª£c frame r·ªóng t·ª´ WebSocket');
        }
        return;
      }

      final data = json.decode(frame.body!);
      if (kDebugMode) {
        print('üì® X·ª≠ l√Ω tin nh·∫Øn chat: $data');
      }

      // T·∫°o model t·ª´ d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c
      final ChatMessageModel message = ChatMessageModel.fromJson(data);

      // G·ªçi callback n·∫øu c√≥
      if (onChatMessageReceived != null) {
        onChatMessageReceived!(message);
      } else {
        if (kDebugMode) {
          print('‚ö†Ô∏è Kh√¥ng c√≥ callback cho tin nh·∫Øn chat');
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå L·ªói khi x·ª≠ l√Ω tin nh·∫Øn chat: $e');
      }
    }
  }

  // Ph∆∞∆°ng th·ª©c x·ª≠ l√Ω th√¥ng b√°o nh·∫≠n ƒë∆∞·ª£c
  void _handleNotificationReceived(StompFrame frame) {
    try {
      if (frame.body == null) {
        if (kDebugMode) {
          print('‚ùå Nh·∫≠n ƒë∆∞·ª£c frame th√¥ng b√°o r·ªóng t·ª´ WebSocket');
        }
        return;
      }

      final data = json.decode(frame.body!);
      if (kDebugMode) {
        print('üîî X·ª≠ l√Ω th√¥ng b√°o: $data');
      }

      // T·∫°o model t·ª´ d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c
      final NotificationModel notification = NotificationModel.fromJson(data);

      // G·ªçi callback n·∫øu c√≥
      if (onNotificationReceived != null) {
        onNotificationReceived!(notification);
      } else {
        if (kDebugMode) {
          print('‚ö†Ô∏è Kh√¥ng c√≥ callback cho th√¥ng b√°o');
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå L·ªói khi x·ª≠ l√Ω th√¥ng b√°o: $e');
      }
    }
  }
}
